<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pixel Marsh Duck Hunt — iPhone Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
    :root { --bg: #000; } /* Changed to black for letterboxing */
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      background: var(--bg);
      font-family: 'VT323', monospace;
      color: #e6e6e6;
      overflow: hidden; /* Prevent scrolling on mobile */
    }
    .wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      position: relative;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #0b0e1a; /* Original game background */
      /* width and height are now set by JS to maintain aspect ratio */
      cursor: crosshair;
      display: block; /* Removes bottom margin/space */
    }
    .hud {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      opacity: .9;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 10px;
      width: 100%;
      max-width: 480px; /* Limit HUD width */
      background: rgba(11, 14, 26, 0.6);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      border-top: 1px solid rgba(255,255,255,0.1);
      box-sizing: border-box;
      padding-bottom: calc(8px + env(safe-area-inset-bottom)); /* iPhone X notch support */
    }
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2px 16px; /* row-gap column-gap */
      text-align: left;
      max-width: 300px;
      margin: 0 auto;
    }
    .tiny { font-size: 10px; opacity: .7; }
    
    /* Shared overlay styles */
    .intro-overlay, .game-over-overlay, .level-complete-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: grid; place-items: center; 
      color: white; text-shadow: 2px 2px 5px black;
      flex-direction: column; gap: 20px; text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    
    /* Specific overlay styles */
    .intro-overlay {
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 20;
        cursor: pointer;
    }
    .game-over-overlay, .level-complete-overlay {
      display: none; /* Hidden by default */
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 10;
      font-size: 40px;
    }
    .game-over-overlay button {
      background: #1b1f2e;
      color: #e6e6e6;
      border: 1px solid #2a2f44;
      padding: 8px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-family: inherit;
      font-size: 16px;
    }

    .score-display { font-size: 30px; text-shadow: 1px 1px 3px black; }
    
    @keyframes pulse {
      50% { opacity: 0.5; }
    }
    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="introOverlay" class="intro-overlay">
      <div class="text-center">
        <div id="introText1" class="text-4xl"></div>
        <div id="introText2" class="text-2xl mt-4"></div>
      </div>
    </div>
    <div id="gameOverOverlay" class="game-over-overlay">
      <span>GAME OVER</span>
      <span id="finalScore" class="score-display">Score: 0</span>
      <button id="restartOverlayButton">Restart</button>
    </div>
    <div id="levelCompleteOverlay" class="level-complete-overlay">
      <span>LEVEL COMPLETE!</span>
      <span id="nextLevelMessage" class="score-display">Prepare for Level 2...</span>
    </div>

    <!-- CANVAS SIZING IS NOW DYNAMIC -->
    <canvas id="game" aria-label="pixel-art bird hunter shooting ducks in a marsh"></canvas>
    
    <!-- OVERLAY HUD -->
    <div id="hud" class="hud" aria-live="polite" aria-atomic="true">
      <div class="stats-grid">
        <div id="scoreDisplay">Score: 0</div>
        <div id="levelDisplay">Level: 1</div>
        <div id="ducksDisplay">Ducks: 0/0</div>
        <div id="ammoDisplay">Ammo: 0</div>
      </div>
      <div class="tiny">Waterfowling · Green Duck: +1 · Goose: +2 · Red Bird: -1</div>
    </div>
  </div>

<script>
(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const introOverlay = document.getElementById('introOverlay');
  const introText1 = document.getElementById('introText1');
  const introText2 = document.getElementById('introText2');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreDisplay = document.getElementById('finalScore');
  const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
  const nextLevelMessage = document.getElementById('nextLevelMessage');
  const hud = document.getElementById('hud');

  // --- Config ---
  const NATIVE_W = 360, NATIVE_H = 640; // Native aspect ratio
  let W = NATIVE_W, H = NATIVE_H; // Dynamic resolution
  const DUCK_SPAWN_BASE = 70;
  let   MAX_DUCKS_ON_SCREEN = 9;
  const PELLETS = 10;
  const PELLET_SPEED = 9.0;
  const RECOIL_FRAMES = 8;
  const DAYLEN = 60 * 60;
  const HIT_R2 = 144;
  const SPRITE_SCALE = 2.5;
  const FOREGROUND_Y_OFFSET = 140;
  
  // --- Audio setup ---
  let audioContext;
  let rainGainNode;
  let backgroundAudioSetup = false;

  function setupBackgroundAudio() {
    if (backgroundAudioSetup || !audioContext) return;
    const bufferSize = 2 * audioContext.sampleRate;
    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    let output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
    const rainSource = audioContext.createBufferSource();
    rainSource.buffer = noiseBuffer; rainSource.loop = true;

    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.value = 600;

    rainGainNode = audioContext.createGain();
    rainGainNode.gain.value = 0;

    rainSource.connect(filter).connect(rainGainNode).connect(audioContext.destination);
    rainSource.start();

    backgroundAudioSetup = true;
  }

  function createAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      setupBackgroundAudio();
    }
  }

  function userGestureAudioUnlock(){
    if (!audioContext) createAudioContext();
    if (audioContext && audioContext.state === 'suspended') audioContext.resume();
    setupBackgroundAudio();
  }

  function playSound(frequency, duration, type, volume) {
    if (!audioContext) return;
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.type = type;
    oscillator.frequency.value = frequency;
    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.start();
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
    oscillator.stop(audioContext.currentTime + duration);
  }
  
  function playJingle(notes, tempo=120) {
    if (!audioContext) return;
    let startTime = audioContext.currentTime;
    const noteDuration = 60 / tempo;
    notes.forEach(note => {
      if (note.freq === null) { startTime += note.duration * noteDuration; return; }
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.type = note.type || 'sine';
      oscillator.frequency.value = note.freq;
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
      gainNode.gain.linearRampToValueAtTime(0.001, startTime + note.duration * noteDuration);
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start(startTime);
      oscillator.stop(startTime + note.duration * noteDuration);
      startTime += note.duration * noteDuration;
    });
  }

  function playShotSound() { playSound(200, 0.1, 'sawtooth', 0.5); playSound(400, 0.05, 'square', 0.2); }
  function playDuckHitSound() { const baseFreq1 = 780 + R(40); const baseFreq2 = 580 + R(40); playSound(baseFreq1, 0.05, 'sine', 0.3); playSound(baseFreq2, 0.05, 'sine', 0.2); }
  function playPenaltySound() { playSound(120, 0.15, 'sawtooth', 0.4); playSound(100, 0.15, 'sawtooth', 0.4); }
  function playDogBark() { playSound(150, 0.08, 'sawtooth', 0.3); setTimeout(() => playSound(180, 0.08, 'sawtooth', 0.3), 100); }
  function playGameOverJingle() { const notes = [ { freq: 261.63, duration: 0.5 }, { freq: 246.94, duration: 0.5 }, { freq: 233.08, duration: 0.5 }, { freq: 220.00, duration: 1.5 } ]; playJingle(notes, 120); }
  function playLevelCompleteJingle() { const notes = [ { freq: 392.00, duration: 0.5 }, { freq: 523.25, duration: 0.5 }, { freq: 659.25, duration: 0.5 }, { freq: 783.99, duration: 1.5 } ]; playJingle(notes, 150); }

  // --- Input state ---
  let mouse = { x: W / 2, y: H * 0.6, down: false };
  let gameOver = false;
  let gameStarted = false;

  // --- Game state ---
  let frame = 0, score = 0, ammo = 0, level = 1;
  let ducksShot = 0;
  let ducksToShoot = 0;
  let pellets = [], ducks = [], splashes = [], reeds = [], puffs = [], ripples = [];
  let clouds = [], raindrops = [];
  let treeLine = [], fencerows = [];
  let weather = { raining: false, until: 0 };
  let hunter = { x: W/2 - 12, y: H - FOREGROUND_Y_OFFSET, aiming: 0, recoil: 0, muzzleFlash: 0 };
  let dogs = [];
  let prevAccuracy = null, nextSpawnAt = 0, currentParams = null, shotsFired = 0;

  // --- Utility ---
  const R = (n=1) => Math.random() * n;
  const RI = (a,b) => Math.floor(a + Math.random()*(b-a+1));
  const clamp = (v,a,b) => v < a ? a : v > b ? b : v;
  const easeOut = (t) => 1 - Math.pow(1 - t, 2);

  function p(x, y, color) { ctx.fillStyle = color; ctx.fillRect(Math.round(x), Math.round(y), 1, 1); }
  function r(x,y,w,h,color) { ctx.fillStyle = color; ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h)); }
  function l(x0,y0,x1,y1,color) { let dx = Math.abs(x1-x0), dy = -Math.abs(y1-y0), sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1; let err = dx + dy; while (true) { p(x0, y0, color); if (x0===x1 && y0===y1) break; let e2 = 2*err; if (e2 >= dy) { err += dy; x0 += sx; } if (e2 <= dx) { err += dx; y0 += sy; } } }
  function pixelCircle(x, y, radius, color) { for (let i=-radius; i<=radius; i++) for (let j=-radius; j<=radius; j++) if (i*i + j*j <= radius*radius) p(x+i, y+j, color); }

  // --- Gradients ---
  function getGradientColor(t, stops) {
    function mix(a, b, t) { return a + (b - a) * t; }
    for (let i = 0; i < stops.length - 1; i++) { const s1 = stops[i]; const s2 = stops[i + 1]; if (t >= s1.t && t <= s2.t) { const localT = (t - s1.t) / (s2.t - s1.t); const r = mix(s1.c[0], s2.c[0], localT); const g = mix(s1.c[1], s2.c[1], localT); const b = mix(s1.c[2], s2.c[2], localT); return `rgb(${r|0},${g|0},${b|0})`; } } return `rgb(${stops[0].c[0]|0},${stops[0].c[1]|0},${stops[0].c[2]|0})`;
  }
  const skyStops = [ {t: 0.00, c: [10, 15, 40]}, {t: 0.20, c: [10, 15, 40]}, {t: 0.25, c: [30, 40, 80]}, {t: 0.28, c: [240, 130, 90]}, {t: 0.35, c: [100, 160, 220]}, {t: 0.50, c: [135, 206, 250]}, {t: 0.70, c: [100, 160, 220]}, {t: 0.80, c: [255, 140, 80]}, {t: 0.85, c: [30, 40, 80]}, {t: 1.00, c: [10, 15, 40]} ];
  const waterStops = [ {t: 0.00, c: [15, 20, 50]}, {t: 0.20, c: [15, 20, 50]}, {t: 0.25, c: [40, 50, 90]}, {t: 0.28, c: [220, 110, 80]}, {t: 0.35, c: [80, 130, 180]}, {t: 0.50, c: [60, 140, 200]}, {t: 0.70, c: [80, 130, 180]}, {t: 0.80, c: [230, 120, 70]}, {t: 0.85, c: [40, 50, 90]}, {t: 1.00, c: [15, 20, 50]} ];
  
  function generateTreeLine() { treeLine = []; for (let i = 0; i < W; i++) { const height = 8 + Math.sin(i * 0.1) * 2 + Math.sin(i * 0.04) * 4 + R(5); treeLine.push(height); } }
  function generateReeds() { reeds = []; for (let i=0;i<100;i++) { reeds.push({ x: RI(0,W-1), h: RI(8,22), seed: R(1000), layer: Math.random() < 0.3 ? 2 : (Math.random() < 0.6 ? 1 : 0), type: Math.random() < 0.2 ? 'cattail' : 'simple' }); } reeds.sort((a, b) => a.layer - b.layer); }
  function generateFencerows() { fencerows = []; for (let i = 0; i < 20; i++) { fencerows.push({ x: RI(0, W - 1), h: RI(5, 15), seed: R(1000), type: Math.random() < 0.2 ? 'post' : 'weed', layer: Math.random() < 0.3 ? 2 : (Math.random() < 0.6 ? 1 : 0) }); } fencerows.sort((a, b) => a.layer - b.layer); }

  function spawnCloud() { const dirRight = Math.random() < 0.5; const cloud = { x: dirRight ? -40 : W + 40, y: RI(8, H * 0.3), vx: (dirRight ? 0.3 : -0.3) * (0.5 + R(0.6)), life: RI(1800, 2400), puffs: [] }; const puffCount = RI(8, 15); for (let i = 0; i < puffCount; i++) cloud.puffs.push({ dx: (R(1) - 0.5) * 30, dy: (R(1) - 0.8) * 10, r: RI(5, 10) }); clouds.push(cloud); }
  function drawClouds() { for (let i = clouds.length - 1; i >= 0; i--) { const c = clouds[i]; c.x += c.vx; c.life--; const t = (frame % DAYLEN) / DAYLEN; const night = (t < 0.25 || t > 0.85); const tone1 = night ? 'rgba(170,187,208,0.7)' : 'rgba(216,230,242,0.7)'; const tone2 = night ? 'rgba(135,155,176,0.6)' : 'rgba(178,192,203,0.6)'; c.puffs.forEach(puff => { ctx.fillStyle = tone1; pixelCircle(c.x + puff.dx, c.y + puff.dy, puff.r); ctx.fillStyle = tone2; pixelCircle(c.x + puff.dx + R(2)-1, c.y + puff.dy + R(2)-1, puff.r * 0.8); }); if (c.x < -60 || c.x > W + 60 || c.life <= 0) clouds.splice(i, 1); } }
  function spawnRainTick() { for (let i=0;i<RI(2,6);i++) raindrops.push({ x: RI(0, W), y: RI(0, H * 0.4), vx: -0.6, vy: 3.6 + R(1.2) }); }
  function drawRain() { const waterY = H - (FOREGROUND_Y_OFFSET - 5); for (let i=raindrops.length-1; i>=0; i--) { const d = raindrops[i]; d.x += d.vx; d.y += d.vy; l(Math.round(d.x), Math.round(d.y-2), Math.round(d.x-1), Math.round(d.y), '#8fb7ff'); if (d.y >= waterY) { makeSplash(d.x, waterY-1); ripples.push({ x: d.x, y: waterY, r: 1, life: 40 }); raindrops.splice(i,1); } else if (d.x < -5 || d.y > H+5) { raindrops.splice(i,1); } } }

  function getLevelParams(l, acc){
    const L = Math.max(1, l); const t = clamp((L-1)/8, 0, 1); const e = easeOut(t);
    const spawnInterval = Math.round(clamp(DUCK_SPAWN_BASE - 52*e - 5*L, 14, 70));
    const maxOnScreen  = clamp(7 + Math.floor(L*0.75), 7, 14);
    let fastProb = L < 2 ? 0.10 * L : clamp(0.15 + 0.08*(L-2) + 0.25*e, 0.15, 0.80);
    if (acc != null && acc < 0.35) fastProb = Math.max(0.08, fastProb - 0.04);
    const gooseProb = clamp(0.01 + 0.004*L, 0.01, 0.05);
    const speedNormal = clamp(1.85 + 0.05*L + 0.30*e, 1.85, 3.00); // Increased
    const speedFast   = clamp(2.60 + 0.06*L + 0.35*e, 2.60, 3.50); // Increased
    const speedGoose  = clamp(1.60 + 0.03*L + 0.20*e, 1.60, 2.60); // Increased
    const ducksNeeded = clamp(5 + Math.round(1.9*L + 2.3*e), 5, 28);
    let ammoBuffer = 1; if (acc != null) { if (acc < 0.35) ammoBuffer = 4; else if (acc < 0.5) ammoBuffer = 3; else if (acc > 0.8) ammoBuffer = 0; }
    return { spawnInterval, maxOnScreen, fastProb, gooseProb, speedNormal, speedFast, speedGoose, ducksNeeded, ammoBuffer };
  }

  function spawnDuck() {
    if (ducks.filter(d => d.alive).length >= MAX_DUCKS_ON_SCREEN) return;
    const fromLeft = Math.random() < 0.5;
    const x = fromLeft ? -10 : W+10;
    const y = RI(H * 0.1, H * 0.4); // Spawn in upper part of screen
    const base = 1.0 + R(1.0);

    const roll = Math.random(); let type = 'normal';
    if (roll < currentParams.gooseProb) type = 'goose'; else if (roll < currentParams.gooseProb + currentParams.fastProb) type = 'fast';

    const vx = (fromLeft ? 1 : -1) * base; const vy = (R(1)-.5)*0.35;
    const duck = { x, y, vx, vy, s: 1, flap: 0, alive: true, fall: 0, frame: 0, type, hit: false, retrieved: false };
    if (type === 'fast') { duck.zigF = 0.32 + R(0.20); duck.zigA = 0.9 + R(0.6); duck.zigPhase = R(Math.PI*2); }
    if (type === 'goose') { duck.zigF = 0.10 + R(0.05); duck.zigA = 0.25 + R(0.15); duck.zigPhase = R(Math.PI*2); }
    ducks.push(duck);
  }

  function makeSplash(x,y) { for (let i=0;i<12;i++) splashes.push({ x, y, vx:(R(1)-.5)*0.9, vy: -R(1.3), life: 40 }); }
  function puff(x,y, n=6) { for (let i=0;i<n;i++) puffs.push({ x, y, vx:(R(1)-.5)*0.5, vy:(R(1)-.5)*0.5, life: 24 }); }

  function shoot(targetX, targetY) {
    if (gameOver || !gameStarted || ammo <= 0) return;
    playShotSound(); ammo--; shotsFired++;
    hunter.recoil = RECOIL_FRAMES;
    const gunTipX = hunter.x+12, gunTipY = hunter.y-20;
    hunter.muzzleFlash = 2;
    puff(gunTipX, gunTipY, 10);
    const dx = targetX - gunTipX, dy = targetY - gunTipY;
    const ang = Math.atan2(dy, dx);
    for (let i=0;i<PELLETS;i++) {
      const spread = (Math.random()-0.5) * 0.20;
      pellets.push({ x: gunTipX, y: gunTipY, vx: Math.cos(ang + spread) * PELLET_SPEED * (0.9 + R(0.3)), vy: Math.sin(ang + spread) * PELLET_SPEED * (0.9 + R(0.3)), life: 70 }); // Increased life from 36
    }
  }

  function drawHunter() {
    const hx = hunter.x, hy = hunter.y;
    const s = SPRITE_SCALE * 0.9; // Slightly smaller scale for hunter
    // Color Palette
    const skin = '#d9a066', skin_dark = '#b57a47';
    const hair = '#45283c';
    const coat = '#5a4a3b', coat_light = '#6d5c4b';
    const vest = '#3a5229', vest_light = '#4b6b33';
    const shirt = '#c2c3c7';
    const pants = '#4a423c', pants_dark = '#3a322c';
    const boots = '#4a3b2a', boots_light = '#6d5c4b';
    const tweed_dark = '#5a524c', tweed_light = '#6d625c';

    const gunWood = '#6d4c3b', gunWoodDark = '#4a3326', gunMetal = '#666', gunMetalDark = '#444';
    const originX = hx + 10*s, originY = hy - 16*s;

    // Draw static body parts first
    ctx.save();
    ctx.translate(hx, hy);
    ctx.scale(s, s);

    // Boots
    r(2, -10, 2, 10, boots); r(6, -10, 2, 10, boots);
    p(2, -1, boots_light); p(6, -1, boots_light);
    
    // Legs
    r(2, -14, 2, 4, pants); r(6, -14, 2, 4, pants);
    p(3, -14, pants_dark); p(7, -14, pants_dark);

    // Body & Coat (without arms)
    r(2, -22, 7, 8, coat);
    p(2,-22, coat_light); p(8,-22, coat_light);
    // Vest
    r(3, -20, 5, 6, vest);
    r(3, -20, 5, 1, vest_light);
    // Shirt collar
    r(4, -21, 3, 1, shirt);

    // Head
    r(3, -27, 5, 4, skin);
    p(7, -26, skin_dark); // Ear
    p(4, -25, hair); // Sideburn
    p(7, -25, hair); // Hair back
    p(8, -26, skin); // Nose
    r(4, -24, 3, 1, hair); // Moustache
    
    // Flat Cap
    r(2, -29, 7, 2, tweed_dark);
    p(3, -29, tweed_light); p(5, -29, tweed_light); p(7, -29, tweed_light);
    p(2, -28, tweed_light); p(4, -28, tweed_light); p(6, -28, tweed_light);
    r(7, -28, 3, 1, tweed_dark);
    
    ctx.restore();

    // Aiming arm & gun
    const ang = Math.atan2(mouse.y - originY, mouse.x - originX);
    const recoilOffset = (hunter.recoil > 0 ? -2 : 0);

    ctx.save(); ctx.translate(originX, originY); ctx.rotate(ang); ctx.scale(s,s);
    
    // Rear (trigger) arm
    ctx.fillStyle = coat;
    ctx.beginPath();
    ctx.moveTo(2, -2); // Shoulder
    ctx.lineTo(-4, 2); // Elbow
    ctx.lineTo(-2, 4); // Hand
    ctx.lineTo(0, 4);
    ctx.lineTo(0, 3);
    ctx.lineTo(4, 0); // Back to shoulder
    ctx.closePath();
    ctx.fill();
    p(-3, 3, coat_light); // Elbow highlight

    // Forward arm and hand
    const arm_sleeve = coat;
    const arm_hand = skin;
    ctx.fillStyle = arm_sleeve;
    ctx.beginPath();
    ctx.moveTo(-6, -2); // Shoulder
    ctx.lineTo(0, 1);   // Elbow
    ctx.lineTo(7, 1);   // Forearm
    ctx.lineTo(9, 3);   // Hand top
    ctx.lineTo(7, 4);   // Hand bottom
    ctx.lineTo(0, 3);   // Bottom of forearm
    ctx.lineTo(-4, 0);  // Back to shoulder
    ctx.closePath();
    ctx.fill();
    r(7, 1, 3, 3, arm_hand); // Hand on forend

    // Stock
    r(-10 + recoilOffset, 0, 10, 2, gunWood); // Longer stock
    p(-11 + recoilOffset, 1, gunWood);
    r(-8 + recoilOffset, 2, 6, 1, gunWoodDark);
    // Action/Receiver
    r(0 + recoilOffset, -1, 4, 3, gunMetal);
    p(1 + recoilOffset, 0, gunMetalDark);
    p(1 + recoilOffset, 2, gunMetalDark);
    // Trigger guard
    p(0 + recoilOffset, 3, gunMetal); p(1 + recoilOffset, 4, gunMetal); p(2 + recoilOffset, 3, gunMetal);
    // Barrels (Over-under)
    r(3 + recoilOffset, -1, 18, 2, gunMetalDark); // Main barrel shape
    r(3 + recoilOffset, -1, 18, 1, gunMetal);     // Top highlight
    // Forend
    r(4 + recoilOffset, 1, 8, 1, gunWood);
    r(5 + recoilOffset, 2, 6, 1, gunWoodDark);
    ctx.restore();

    // Muzzle flash
    if (hunter.muzzleFlash > 0) {
      const endX = originX + Math.cos(ang) * (22*s + recoilOffset);
      const endY = originY + Math.sin(ang) * (22*s + recoilOffset);
      const fx = endX, fy = endY;
      r(fx - 1*s, fy - 1*s, 3*s, 3*s, '#fff3a0'); p(fx + 2*s, fy, '#ffd46b'); p(fx - 2*s, fy, '#ffd46b'); p(fx, fy + 2*s, '#ffd46b'); p(fx, fy - 2*s, '#ffd46b');
    }
  }
  
  const dogSprites = {
    carrying: [
      (ctx, x, y) => { const light = '#a3713f', mid = '#734c2b', black = '#111'; r(x+1, y+8, 10, 5, mid); r(x+2, y+9, 8, 3, light); r(x+9, y+7, 4, 4, mid); r(x+10, y+8, 2, 2, light); r(x+12, y+8, 2, 1, black); p(x+10, y+8, black); r(x+8, y+6, 2, 2, mid); r(x, y+10, 2, 2, mid); r(x+2, y+13, 2, 4, mid); r(x+3, y+13, 1, 3, light); r(x+8, y+13, 2, 4, mid); r(x+9, y+13, 1, 3, light); },
      (ctx, x, y) => { const light = '#a3713f', mid = '#734c2b', black = '#111'; r(x+1, y+9, 10, 5, mid); r(x+2, y+10, 8, 3, light); r(x+9, y+8, 4, 4, mid); r(x+10, y+9, 2, 2, light); r(x+12, y+9, 2, 1, black); p(x+10, y+9, black); r(x+8, y+7, 2, 2, mid); r(x, y+11, 2, 2, mid); r(x+3, y+14, 2, 3, mid); r(x+4, y+14, 1, 2, light); r(x+7, y+14, 2, 3, mid); r(x+8, y+14, 1, 2, light); },
      (ctx, x, y) => { const light = '#a3713f', mid = '#734c2b', black = '#111'; r(x+1, y+8, 10, 5, mid); r(x+2, y+9, 8, 3, light); r(x+9, y+7, 4, 4, mid); r(x+10, y+8, 2, 2, light); r(x+12, y+8, 2, 1, black); p(x+10, y+8, black); r(x+8, y+6, 2, 2, mid); r(x, y+10, 2, 2, mid); r(x+8, y+13, 2, 4, mid); r(x+9, y+13, 1, 3, light); r(x+2, y+13, 2, 4, mid); r(x+3, y+13, 1, 3, light); },
      (ctx, x, y) => { const light = '#a3713f', mid = '#734c2b', black = '#111'; r(x+1, y+9, 10, 5, mid); r(x+2, y+10, 8, 3, light); r(x+9, y+8, 4, 4, mid); r(x+10, y+9, 2, 2, light); r(x+12, y+9, 2, 1, black); p(x+10, y+9, black); r(x+8, y+7, 2, 2, mid); r(x, y+11, 2, 2, mid); r(x+7, y+14, 2, 3, mid); r(x+8, y+14, 1, 2, light); r(x+3, y+14, 2, 3, mid); r(x+4, y+14, 1, 2, light); }
    ]
  };

  function spawnDog(duckX, duckType) { playDogBark(); const dirRight = duckX > W / 2; const vx = dirRight ? 1.2 : -1.2; dogs.push({ x: duckX, y: H - (FOREGROUND_Y_OFFSET - 5), frame: 0, state: 'carrying', vx, duckType }); }
  function drawDogs() {
    if (!dogs || !Array.isArray(dogs)) return;
    for (const dog of dogs) {
      const sprite = dogSprites[dog.state][(dog.frame / 5 | 0) % dogSprites[dog.state].length];
      if (sprite) {
        ctx.save();
        if (dog.vx < 0) { ctx.translate(dog.x + 16, dog.y); ctx.scale(-1, 1); } else { ctx.translate(dog.x, dog.y); }
        ctx.scale(SPRITE_SCALE, SPRITE_SCALE); // Scale the dog
        sprite(ctx, 0, 0);
        switch(dog.duckType) {
            case 'goose': r(12, 8, 5, 2, '#7a6d5a'); r(16, 7, 2, 3, '#111'); p(18, 7, '#333'); break;
            case 'fast': r(12, 8, 5, 2, '#e04242'); r(16, 7, 2, 2, '#c82828'); p(18, 8, '#ffb86b'); break;
            default: r(12, 8, 4, 2, '#2a3b28'); r(15, 7, 2, 2, '#2b6d2f'); p(17, 8, '#cca23a'); break;
        }
        ctx.restore();
      }
    }
  }

  function drawReeds() {
    const waterY = H - (FOREGROUND_Y_OFFSET - 5);
    reeds.forEach(rd => {
      const sway = Math.sin(frame*0.035 + rd.seed) * (1.2 - rd.layer * 0.4);
      const x = rd.x;
      const y = waterY;
      const green1 = rd.layer === 2 ? '#a3c95a' : (rd.layer === 1 ? '#7aa14a' : '#4b6b33');
      const green2 = rd.layer === 2 ? '#7aa14a' : (rd.layer === 1 ? '#4b6b33' : '#3a5229');
      const cattailColor = rd.layer === 2 ? '#7a5634' : (rd.layer === 1 ? '#6a4a2e' : '#5a3e2b');

      // Draw the main stalk
      for (let j = 0; j < rd.h; j++) {
          const currentSway = sway * (j / rd.h);
          p(x + currentSway, y - j, j > rd.h / 2 ? green1 : green2);
          // Add a shadow/thickness
          if (rd.layer > 0) p(x + currentSway - 1, y - j, green2);
      }

      // Add leaves for non-cattail reeds
      if (rd.type !== 'cattail') {
          const leafCount = Math.floor(rd.h / 8); // Add a leaf every 8 pixels of height
          for (let i = 0; i < leafCount; i++) {
              const leafY = y - (i * 8) - 4;
              const leafSway = sway * ((H - leafY) / H);
              const direction = (rd.seed * i) % 2 === 0 ? 1 : -1; // Alternate leaf direction
              const leafLength = 3 + R(2);
              for (let k = 0; k < leafLength; k++) {
                  p(x + leafSway + (k * direction), leafY - k, green1);
              }
          }
      }

      // Draw cattail top
      if (rd.type === 'cattail') {
          const topY = y - rd.h;
          const topSway = sway;
          r(x + topSway - 1, topY - 4, 2, 4, cattailColor);
      }
    });
  }

  let starField = null;
  function ensureStars(){ if (!starField) starField = Array.from({length: 60}, () => ({x: RI(0,W), y: RI(0, H * 0.5), a: Math.random()*0.8})); }
  function drawStars(sunElev){ if (sunElev > 0.1) { starField = null; return; } ensureStars(); ctx.globalAlpha = clamp(1 - (sunElev / 0.1), 0, 1); for (const s of starField) p(s.x, s.y, `rgba(255,255,255,${s.a})`); ctx.globalAlpha = 1; }

  function drawBackground() {
    const gameTime = (frame % DAYLEN) / DAYLEN;
    const treeLineY = H * 0.5;
    const sky = getGradientColor(gameTime, skyStops); const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0, sky); g.addColorStop(1, '#14324f'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    const theta = 2 * Math.PI * (gameTime - 0.25); const sunElev = Math.sin(theta); const sunX = W/2 - (W/2) * Math.cos(theta); const sunY = treeLineY - sunElev * (treeLineY);
    if (sunElev > 0 && sunY < treeLineY) { ctx.globalAlpha = 0.9 * Math.min(1, sunElev+0.2); pixelCircle(Math.round(sunX), Math.round(sunY), 3, '#ffe6a6'); ctx.globalAlpha = 0.3; pixelCircle(Math.round(sunX), Math.round(sunY), 6, '#ffd48a'); ctx.globalAlpha = 1; }
    const moonTheta = theta + Math.PI; const moonElev = Math.sin(moonTheta); const moonX = W/2 - (W/2) * Math.cos(moonTheta); const moonY = treeLineY - moonElev * (treeLineY);
    if (moonElev > 0 && moonY < treeLineY) { ctx.globalAlpha = 0.8 * Math.min(1, moonElev+0.2); pixelCircle(Math.round(moonX), Math.round(moonY), 2, '#dfe7ff'); ctx.globalAlpha = 0.4; pixelCircle(Math.round(moonX), Math.round(moonY), 4, '#dfe7ff'); ctx.globalAlpha = 1; }
    drawStars(sunElev);
    
    ctx.fillStyle = '#0b2330'; ctx.globalAlpha = 0.7; for (let i = 0; i < W; i++) r(i, treeLineY - treeLine[i], 1, treeLine[i] + 8);
    
    drawClouds();
    
    ctx.globalAlpha = 1;
    const waterY = H - (FOREGROUND_Y_OFFSET - 5);
    const waterHeight = FOREGROUND_Y_OFFSET - 5;
    const waterColor = getGradientColor(gameTime, waterStops); r(0, waterY, W, waterHeight, waterColor); for (let i=0;i<waterHeight;i++) { const yy = waterY + i; if (i%2===0) for (let x=0;x<W;x+=RI(6,12)) r(x + Math.sin((frame*0.04 + i)*0.8)*2.2, yy, RI(2,5), waterColor); }
    
    // Dynamic water highlights
    const waterHighlight = `rgba(255,255,255,0.1)`;
    for (let i=0; i < waterHeight; i+=2) {
        const yy = waterY + i;
        for (let x=0; x<W; x+=RI(10,20)) {
            r(x + Math.sin((frame*0.06 + i)*0.5)*3.5, yy, RI(3,6), waterHighlight);
        }
    }
  }

  function drawDuck(d) {
    const x = Math.round(d.x), y = Math.round(d.y); const right = d.vx > 0;
    ctx.save();
    ctx.translate(x, y);
    if (!right) ctx.scale(-1, 1);
    ctx.scale(SPRITE_SCALE, SPRITE_SCALE); // Scale the duck

    if (d.type === 'goose') {
      // Body (larger/longer, grey-brown)
      r(-6, 0, 12, 5, '#7a6d5a'); r(-5, 1, 10, 3, '#9c8f7a');
      // Neck & head (black)
      r(3, -5, 2, 5, '#111'); r(4, -6, 3, 3, '#111');
      // White cheek patch
      r(5, -5, 2, 1, '#eee');
      // Bill (dark)
      r(7, -5, 2, 1, '#333');
      
      // Wing flaps (improved 4-frame animation)
      const wing_dark = '#6b5d4f'; // Darker tone for main wing body
      const wing_light = '#8c7d6b'; // Lighter tone for highlights
      const flapFrame = Math.floor(d.flap / 3); // Creates 4 frames for a smoother cycle

      switch (flapFrame) {
          case 0: // Wings up
              ctx.fillStyle = wing_dark;
              r(-6, -4, 9, 3);
              p(3, -3, wing_dark); p(4,-2, wing_dark);
              ctx.fillStyle = wing_light;
              r(-5, -4, 7, 1);
              break;
          case 1: // Wings out (powerful)
              ctx.fillStyle = wing_dark;
              r(-8, -1, 15, 2);
              r(-7, 0, 13, 2);
              ctx.fillStyle = wing_light;
              r(-7, -1, 13, 1);
              break;
          case 2: // Wings down
              ctx.fillStyle = wing_dark;
              r(-6, 2, 9, 3);
              p(3, 3, wing_dark); p(4,4, wing_dark);
              ctx.fillStyle = wing_light;
              r(-5, 2, 7, 1);
              break;
          case 3: // Recovery stroke
              ctx.fillStyle = wing_dark;
              r(-8, 0, 14, 2);
              r(-6, 1, 11, 1);
              ctx.fillStyle = wing_light;
              r(-7, 0, 12, 1);
              break;
      }
    } else if (d.type === 'fast') {
      // slim body
      r(-5, 0, 9, 2, '#e04242'); r(3, -2, 2, 2, '#c82828'); r(5, -1, 2, 1, '#ffb86b');
      // pointed wings, rapid flaps
      const flap = Math.floor(d.flap / 2) % 3; ctx.fillStyle = '#e85b5b';
      if (flap === 0) { r(-2, -3, 6, 1); r(-1, -2, 4, 1); } else if (flap === 1) { r(-3, 0, 7, 1); r(-2, 1, 5, 1); } else { r(-2, 2, 6, 1); r(-1, 3, 4, 1); }
    } else { // NORMAL DUCK
      const headC = '#2b6d2f', bodyC1 = '#5a3e2b', bodyC2 = '#87614b', wingC = '#4a3326', billC = '#cca23a', eyeC = '#fff';
      r(-4, 0, 8, 4, bodyC1); r(-3, 1, 6, 3, bodyC2);
      r(3, -3, 3, 3, headC); p(5, -2, eyeC); r(6, -2, 2, 1, billC);
      const flapFrame = Math.floor(d.flap / 3); ctx.fillStyle = wingC;
      switch(flapFrame) { case 0: r(-2, -3, 5, 2); r(-1, -2, 4, 2); break; case 1: r(-3, 0, 6, 2); r(-2, 1, 5, 2); break; case 2: r(-2, 2, 5, 2); r(-1, 3, 4, 2); break; }
    }
    ctx.restore();
  }
  
  function updateHUD() {
    document.getElementById('ducksDisplay').textContent = `Ducks: ${ducksShot}/${ducksToShoot}`;
    document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
    document.getElementById('levelDisplay').textContent = `Level: ${level}`;
    const ammoEl = document.getElementById('ammoDisplay'); ammoEl.textContent = `Ammo: ${ammo}`; ammoEl.style.color = ammo <= 2 ? '#ffb3b3' : '#e6e6e6';
  }
  
  function update() {
    try {
      if (gameOver || !gameStarted) {
        requestAnimationFrame(update);
        return;
      }
      frame++;
      
      hunter.y = H - FOREGROUND_Y_OFFSET;

      if (dogs && Array.isArray(dogs)) { for (let i = dogs.length - 1; i >= 0; i--) { const dog = dogs[i]; dog.frame++; if (dog.state === 'carrying') { dog.x += dog.vx; if ((dog.vx > 0 && dog.x > W + 30) || (dog.vx < 0 && dog.x < -30)) dogs.splice(i, 1); } } }
      if (ducksShot >= ducksToShoot) { startNextLevel(); return; }
      if (ammo <= 0 && ducksShot < ducksToShoot && pellets.length === 0) { gameOver = true; hud.style.display = 'none'; gameOverOverlay.style.display = 'grid'; finalScoreDisplay.textContent = `Score: ${score}`; playGameOverJingle(); return; }

      if (!weather.raining && Math.random() < 0.0006) { weather.raining = true; weather.until = frame + RI(500, 1000); }
      if (weather.raining && frame > weather.until) { weather.raining = false; if (rainGainNode && audioContext) { const now = audioContext.currentTime; rainGainNode.gain.setValueAtTime(rainGainNode.gain.value, now); rainGainNode.gain.linearRampToValueAtTime(0.0001, now + 1.5); } }
      if (weather.raining && rainGainNode && rainGainNode.gain.value < 0.1) { if (audioContext) rainGainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.8); }

      drawBackground();
      if (frame % 90 === 0 && clouds.length < 10) spawnCloud();
      if (weather.raining) { spawnRainTick(); drawRain(); }
      if (frame >= nextSpawnAt) { spawnDuck(); const jitter = RI(-6, 6); nextSpawnAt = frame + Math.max(16, currentParams.spawnInterval + jitter); }

      for (let i=ducks.length-1; i>=0; i--) {
        const d = ducks[i];
        if (d.alive) { const speedMul = d.type === 'fast' ? currentParams.speedFast : (d.type === 'goose' ? currentParams.speedGoose : currentParams.speedNormal); let zig = 0; if (d.type === 'fast') zig = Math.sin(frame * (d.zigF||0.32) + (d.zigPhase||0)) * (d.zigA||1.0); else if (d.type === 'goose') zig = Math.sin(frame * (d.zigF||0.12) + (d.zigPhase||0)) * (d.zigA||0.3); else zig = Math.sin(frame*0.06 + i)*0.12; d.x += d.vx * speedMul; d.y += d.vy * speedMul + zig; d.flap = (d.flap+1)%12; if (d.x < -20 || d.x > W+20) { ducks.splice(i,1); continue; } } 
        else { d.fall += 0.1; d.y += d.fall; d.x += d.vx*0.45; if (d.y > H - (FOREGROUND_Y_OFFSET - 3) && !d.retrieved) { makeSplash(d.x, H - (FOREGROUND_Y_OFFSET - 3)); spawnDog(d.x, d.type); d.retrieved = true; } if (d.y > H + 10) { ducks.splice(i, 1); continue; } }
        drawDuck(d);
      }
      
      for (let i=pellets.length-1; i>=0; i--) {
        const s = pellets[i]; s.x += s.vx; s.y += s.vy; s.life--; if (s.life>0) p(s.x, s.y, '#fffbd1'); if (s.life<=0 || s.x<0||s.x>W||s.y<0||s.y>H) { pellets.splice(i,1); continue; }
        let hit = false;
        for (let j=0;j<ducks.length;j++) { const d = ducks[j]; if (!d.alive) continue; const dx = s.x - d.x, dy = s.y - d.y; if (dx*dx + dy*dy < HIT_R2) { d.alive = false; d.hit = true; if (d.type === 'fast') { score -= 1; ducksShot = Math.max(0, ducksShot - 1); playPenaltySound(); } else if (d.type === 'goose') { score += 20; ducksShot += 2; playDuckHitSound(); } else { score += 10; ducksShot++; playDuckHitSound(); } puff(d.x, d.y, 8); pellets.splice(i,1); hit = true; break; } }
        if (hit) continue;
      }

      for (let i=splashes.length-1;i>=0;i--) { const sp = splashes[i]; sp.x += sp.vx; sp.y += sp.vy; sp.vy += 0.05; sp.life--; p(sp.x, sp.y, '#d7f0ff'); if (sp.life<=0) splashes.splice(i,1); }
      for (let i=puffs.length-1;i>=0;i--) { const pf = puffs[i]; pf.x += pf.vx; pf.y += pf.vy; pf.life--; p(pf.x, pf.y, '#d8e2f2'); if (pf.life<=0) puffs.splice(i,1); }
      
      for (let i = ripples.length - 1; i >= 0; i--) {
          const ripple = ripples[i]; ripple.r += 0.5; ripple.life--; ctx.beginPath(); ctx.ellipse(ripple.x, ripple.y, ripple.r, ripple.r * 0.4, 0, 0, 2 * Math.PI); ctx.globalAlpha = clamp(ripple.life / 40, 0, 1) * 0.6; const waterColor = getGradientColor((frame % DAYLEN) / DAYLEN, waterStops); ctx.strokeStyle = waterColor; ctx.lineWidth = 1; ctx.stroke();
          if (ripple.life <= 0) { ripples.splice(i, 1); }
      }
      ctx.globalAlpha = 1;

      if (hunter.recoil>0) hunter.recoil--; if (hunter.muzzleFlash>0) hunter.muzzleFlash--;
      drawReeds(); drawHunter(); drawDogs();
      updateHUD();
      ctx.globalAlpha = .07; for (let y=0;y<H;y+=2) r(0,y,W,1,'#000'); ctx.globalAlpha = 1;
      requestAnimationFrame(update);
    } catch (e) {
      console.error("An error occurred in the game loop:", e);
      gameOver = true; hud.style.display = 'none'; gameOverOverlay.style.display = 'grid'; finalScoreDisplay.textContent = `An error occurred. Please try restarting.`;
    }
  }

  // --- Input events (Tap-to-Shoot) ---
  function canvasPos(e){ 
    const rect = canvas.getBoundingClientRect(); 
    const sx = W / rect.width; 
    const sy = H / rect.height; 
    return { 
      x: (e.clientX - rect.left) * sx, 
      y: (e.clientY - rect.top) * sy 
    }; 
  }
  
  canvas.addEventListener('mousemove', e => { const m = canvasPos(e); mouse.x = m.x; mouse.y = m.y; });
  canvas.addEventListener('mousedown', e => { mouse.down = true; const m = canvasPos(e); shoot(m.x, m.y); });
  canvas.addEventListener('mouseup', () => mouse.down = false);

  canvas.addEventListener('touchstart', e => { const t = e.changedTouches[0]; const m = canvasPos(t); mouse.x = m.x; mouse.y = m.y; shoot(m.x, m.y); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchmove', e => { const t = e.changedTouches[0]; const m = canvasPos(t); mouse.x = m.x; mouse.y = m.y; e.preventDefault(); }, {passive:false});

  // Buttons
  document.getElementById('restartOverlayButton').onclick = () => restart();
  
  function restart(){
    gameOver = false;
    hud.style.display = 'flex';
    gameOverOverlay.style.display = 'none'; 
    levelCompleteOverlay.style.display = 'none';
    score = 0; level = 0; ducksShot = 0; ducksToShoot = 0; ammo = 0;
    ducks = []; pellets = []; splashes = []; puffs = []; ripples = []; clouds = []; raindrops = []; dogs = [];
    frame = 0; weather = {raining:false, until:0}; starField = null; shotsFired = 0; prevAccuracy = null;
    if (rainGainNode && audioContext) rainGainNode.gain.setValueAtTime(0, audioContext.currentTime);
    generateTreeLine(); 
    generateReeds(); 
    generateFencerows();
    startNextLevel();
    // BUG FIX: Restart the animation loop
    requestAnimationFrame(update);
  }

  function startNextLevel() {
    const acc = (shotsFired > 0) ? (ducksShot / shotsFired) : null; prevAccuracy = acc; level++; ducksShot = 0; 
    currentParams = getLevelParams(level, acc); MAX_DUCKS_ON_SCREEN = currentParams.maxOnScreen;
    ducksToShoot = currentParams.ducksNeeded; ammo = ducksToShoot + currentParams.ammoBuffer; ducks = [];
    nextSpawnAt = frame + 6;
    if (level > 1) {
        playLevelCompleteJingle();
        hud.style.display = 'none';
        levelCompleteOverlay.style.display = 'grid';
        nextLevelMessage.textContent = `Level ${level}`;
        setTimeout(() => {
            hud.style.display = 'flex';
            levelCompleteOverlay.style.display = 'none';
            // BUG FIX: Restart the animation loop after level transition
            requestAnimationFrame(update); 
        }, 1500);
    } 
  }

  function startGame(e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    document.querySelector('.wrap').removeEventListener('pointerdown', startGame);
    window.removeEventListener('keydown', startGame);
    userGestureAudioUnlock();
    introOverlay.style.display = 'none';
    hud.style.display = 'flex';
    gameStarted = true;
    restart();
  }

  function fit() {
    const aspectRatio = NATIVE_W / NATIVE_H;
    let newWidth = window.innerWidth;
    let newHeight = window.innerHeight;
    const windowRatio = newWidth / newHeight;

    if (windowRatio > aspectRatio) {
        newWidth = newHeight * aspectRatio;
    } else {
        newHeight = newWidth / aspectRatio;
    }

    canvas.style.width = newWidth + 'px';
    canvas.style.height = newHeight + 'px';
    
    // Set the internal resolution once
    canvas.width = NATIVE_W;
    canvas.height = NATIVE_H;

    W = NATIVE_W;
    H = NATIVE_H;
    
    hunter.x = W/2 - 12;
    hunter.y = H - FOREGROUND_Y_OFFSET;
  }

  function init() {
    hud.style.display = 'none';
    introText1.textContent = 'Rose & Scroll presents';
    introText2.textContent = '';
    setTimeout(() => {
        introText1.textContent = 'Waterfowling';
        introText2.innerHTML = '<div class="mt-8 text-2xl opacity-80 animate-pulse">Tap anywhere to Start</div>';
        document.querySelector('.wrap').addEventListener('pointerdown', startGame, { once: true });
        window.addEventListener('keydown', startGame, { once: true });
    }, 2500);
  }

  window.addEventListener('resize', fit);
  fit();
  init();
})();
</script>
</body>
</html>
